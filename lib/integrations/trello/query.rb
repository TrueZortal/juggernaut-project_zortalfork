# frozen_string_literal: true

require_relative '../../requests'
require_relative 'config'
require_relative '../../google/calendar'
require 'date'

module Integrations
  module Trello
    class Query
      def initialize
        @request_adapter = Requests::Adapter.new
        @config = Integrations::Trello::Config.new
      end

      def run(entity:, id:)
        request_path = build_path(entity: entity, query_id: id)
        response = @request_adapter.get_request(request_path, request_headers)
        formatted_response = format_json(response)
        {
          name: formatted_response['name'],
          url: formatted_response['shortUrl'],
          trello_id: formatted_response['id']
        }
      end

      def run_lists_query(entity:, id:)
        request_path = build_path_lists(entity: entity, query_id: id)
        response = @request_adapter.get_request(request_path, request_headers)
        formatted_response = format_json(response)
        lists = []
        formatted_response.each do |list|
          lists.push(
            {
              id: list['id'],
              name: list['name']
            }
          )
        end
        lists
      end

      def run_cards_query(entity:, id:)
        request_path = build_path_cards(query_id: id)
        response = @request_adapter.get_request(request_path, request_headers)
        # puts "Card query response = #{response}"
        formatted_response = format_json(response)
        cards = []
        formatted_response.each do |card|
          # puts "Card label id for #{card['name']} = #{card['idLabels']}"
          cards.push(
            {
              id: card['id'],
              name: card['name'],
              description: card['desc'],
              url: card['url']
            }
          )
        end
        cards
      end

      def run_create_cards_command(list_id:)
        request_path = build_path_create_cards
        wanted_date = Date.today.next_day
        # label_ids(wanted_date)
        description = description_template(wanted_date)
        payload = JSON.generate(
          {
            'idList' => '603e0a24aa367736761d644d',
            'name' => "Important task list for #{wanted_date.strftime('%A')} (#{wanted_date})",
            'desc' => description,
            'idLabels' => label_ids(wanted_date)
          }
        )
        # puts "data = #{wanted_date}"
        # puts "description_template = \n#{description}"
        response = @request_adapter.post_request(request_path, request_headers, payload)
        response
      end

      private

      def label_ids(given_date)
        if given_date.saturday? || given_date.sunday?
          '6013ff1d2a33cb7d0e859ede'
        else
          '6013fee860fd681cc81bf12f'
        end
      end

      def description_template(given_date)
        "Intencje > Wymagania
✅/❌

Chcę zrobić:

#{list_important_tasks_for_the_day}

Praca:

#{list_important_work_tasks_for(given_date)}

Umówione spotkania:

#{list_meetings_for(given_date)}

Nice to have:

#{list_nice_to_haves_for_the_day}

Moje zadania strategiczne: (📥)

#{list_strategic_tasks_for_the_day}

Obiecałem innym:

#{list_obligations_to_others_for_the_day}

        generated by Project Juggernaut"
      end

      def list_important_tasks_for_the_day
        "- ✅ Zrobienie tej listy z poziomu skryptu\n- rozpisz dalsze ważne zadania\n- spójrz na tę listę po pracy"
      end

      def list_important_work_tasks_for(given_date)
        work_task_template = '- notatka w Apple Notes'
        if given_date.monday?
          work_task_template + "\n- podsumowanie poprzedniego tygodnia"
        else
          work_task_template
        end
      end

      def list_meetings_for(given_date)
        calendars = %w[primary work rebased family_shared]
        all_events = []

        calendars.each do |calendar_name|
          all_events += gather_data(given_date, calendar_name)
        end

        all_events.join("\n")
      end

      def gather_data(given_date, calendar_name)
        formatted_events = []
        calendar = Google::Calendar.new(calendar_name: calendar_name)
        events = calendar.fetch_events_from_short(given_date)
        # puts "calendar_events inside list_meetings_for = #{events}"
        events.each do |event|
          start_date_time = event.start.date_time
          end_date_time = event.end.date_time
          if start_date_time.nil?
            puts "Start date was blank for #{event.summary}"
          else
            # puts "event.summary = #{event.summary}"
            if event.summary == 'Początek dnia pracy' || event.summary == 'Koniec dnia pracy'
              puts "We're skipping the work start/end events"
            else
              # puts "event.original_start_time = #{event.original_start_time}"
              # puts "event.original_start_time.date_time = #{event.original_start_time.date_time}"
              # puts "event.start = #{event.start}"
              # puts "event.start.date_time = #{event.start.date_time}"
              # puts "start_date.time = #{start_date_time.strftime('%k:%M')}"
              # puts "start_date.hour = #{start_date_time.hour}"
              # puts "event.end = #{event.end}"
              # puts "event.end.date_time = #{event.end.date_time}"
              # puts "end_date_time.time = #{end_date_time.strftime('%k:%M')}"
              start_time_formatted = start_date_time.strftime('%k:%M')
              end_time_formatted = end_date_time.strftime('%k:%M')
              event_formatted = "- #{start_time_formatted}-#{end_time_formatted} #{event.summary} (#{calendar_name})"
              # puts event_formatted
              formatted_events.push event_formatted
            end
          end
          # event.start.date_time && event.end.date_time are empty for all-day events
        end
        # puts 'formatted events:'
        # puts formatted_events.join("\n")

        # calendar.add_list_of_entries_no_duplicates(prepared_entry_list)
        # TODO: get this list from Google Calendar
        # "- spotkanie1 8:00-9:00\n- spotkanie2 10:00-11:00\n- spotkanie3 13:00-19:00"
        formatted_events
      end

      def list_nice_to_haves_for_the_day
        "- Obiad\n- Chiński 🈸\n- Poczytaj przez 30 minut dla radości ❤️"
      end

      def list_strategic_tasks_for_the_day
        "- Co tutaj?\n- Co dalej?"
      end

      def list_obligations_to_others_for_the_day
        "- Dominika zakładka \"Kariera\"\n- Mariusz nosorożce"
      end

      attr_reader :config

      def build_path(entity:, query_id:)
        "https://api.trello.com/1/#{query_structure(entity, query_id)}?#{auth_params}"
      end

      def build_path_lists(entity:, query_id:)
        "https://api.trello.com/1/#{query_structure(entity, query_id)}/lists?#{auth_params}"
      end

      def build_path_cards(query_id:)
        "https://api.trello.com/1/lists/#{query_id}/cards?fields=all&#{auth_params}"
      end

      def build_path_create_cards
        "https://api.trello.com/1/cards?#{auth_params}"
      end

      def request_headers
        [{ key: 'Accept', value: 'application/json' }]
      end

      def auth_params
        @config.auth
      end

      def query_structure(entity, entity_id)
        @config.fetch_url_structure(entity: entity, id: entity_id)
      end

      def format_json(response)
        status, body = response.values_at(:status, :body)
        return [] if status != 200

        JSON.parse(body)
      end
    end
  end
end
